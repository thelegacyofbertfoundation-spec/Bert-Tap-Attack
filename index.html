<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bert Tap Attack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff; font-family: 'Arial', sans-serif; text-align: center; 
            height: 100vh; display: flex; flex-direction: column; 
            justify-content: space-between; overflow: hidden; touch-action: manipulation;
        }
        #header { padding-top: 20px; position: relative; }
        #boost-timer-container { width: 220px; margin: 0 auto 10px; }
        .boost-timer-row { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .boost-timer-label { font-size: 0.65rem; color: #bbb; min-width: 50px; }
        .boost-timer-bar-wrapper { flex: 1; }
        .boost-timer-bar-bg { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; border: 1px solid #555; }
        .boost-timer-bar { width: 100%; height: 100%; transition: width 0.3s; }
        .tap-timer-bar { background: linear-gradient(90deg, #e67e22 0%, #f39c12 100%); }
        .regen-timer-bar { background: linear-gradient(90deg, #3498db 0%, #2ecc71 100%); }
        #unlocks-btn { position: absolute; top: 60px; right: 20px; background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: bold; font-size: 0.9rem; cursor: pointer; box-shadow: 0 4px 10px rgba(155, 89, 182, 0.3); }
        #unlocks-btn:active { transform: scale(0.95); }
        .unlocks-panel { background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 15px; width: 90%; max-width: 400px; margin-bottom: 10px; position: absolute; top: 70px; left: 50%; transform: translateX(-50%); box-shadow: 0 5px 20px rgba(0,0,0,0.5); border: 2px solid #9b59b6; z-index: 100; max-height: 70vh; overflow-y: auto; }
        .card-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 15px; }
        .card-item { background: rgba(255, 255, 255, 0.05); border-radius: 10px; padding: 15px; text-align: center; border: 2px solid #555; position: relative; }
        .card-item.locked { opacity: 0.5; filter: grayscale(100%); }
        .card-item.unlocked { border-color: #9b59b6; box-shadow: 0 0 15px rgba(155, 89, 182, 0.5); }
        .card-image { width: 100%; height: 120px; object-fit: contain; margin-bottom: 10px; }
        .card-locked-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; }
        .card-name { font-weight: bold; color: #f1c40f; font-size: 0.9rem; margin-bottom: 5px; }
        .card-cost { color: #bbb; font-size: 0.8rem; margin-bottom: 10px; }
        .card-unlock-btn { background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; border: none; padding: 8px 15px; border-radius: 15px; font-weight: bold; cursor: pointer; font-size: 0.85rem; width: 100%; }
        .card-unlock-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #coin-icon { width: 120px; height: 120px; margin-bottom: 10px; animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-10px); } }
        #score { font-size: 3.5rem; font-weight: bold; text-shadow: 0 0 20px rgba(241, 196, 15, 0.5); margin: 10px 0; }
        #game-area { flex: 1; display: flex; align-items: center; justify-content: center; position: relative; }
        #face { width: 98vw; cursor: pointer; transition: transform 0.1s; user-select: none; }
        #face:active { transform: scale(0.92); }
        #face.flash { animation: flash-effect 0.2s ease-out; }
        @keyframes flash-effect { 
            0% { filter: brightness(1); } 
            50% { filter: brightness(1.8); } 
            100% { filter: brightness(1); } 
        }
        .tap-effect { position: absolute; color: #f1c40f; font-weight: bold; font-size: 1.5rem; pointer-events: none; animation: floatUp 1s ease-out forwards; }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-100px); } }
        .footer { padding: 20px 20px 30px 20px; display: flex; flex-direction: column; align-items: center; gap: 12px; background: rgba(0, 0, 0, 0.3); position: relative; }
        #energy-label { font-size: 0.85rem; color: #bbb; margin-bottom: 5px; }
        #energy-container { width: 90%; max-width: 400px; background: #333; height: 14px; border-radius: 10px; overflow: hidden; border: 2px solid #444; }
        #energy-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #f39c12 0%, #f1c40f 100%); transition: width 0.2s; }
        .btn { background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); color: white; border: none; padding: 14px 20px; border-radius: 30px; font-weight: bold; width: 90%; max-width: 400px; font-size: 0.95rem; cursor: pointer; transition: all 0.3s; }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.6; }
        .btn-small { padding: 12px 20px; font-size: 0.95rem; width: auto; min-width: 150px; }
        .badge { position: absolute; top: -8px; right: -8px; background: #e74c3c; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: bold; border: 2px solid #1a1a1a; }
        .refill-panel { background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 15px; width: 90%; max-width: 400px; margin-bottom: 10px; position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%); box-shadow: 0 -5px 20px rgba(0,0,0,0.5); border: 2px solid #3498db; }
        .refill-info { text-align: center; margin: 15px 0; }
        .refill-count { font-size: 3rem; font-weight: bold; color: #3498db; }
        .refill-text { color: #bbb; font-size: 0.9rem; margin: 10px 0; line-height: 1.6; }
        .boost-panel { background: rgba(0, 0, 0, 0.95); padding: 15px; border-radius: 15px; width: 90%; max-width: 400px; margin-bottom: 10px; position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%); box-shadow: 0 -5px 20px rgba(0,0,0,0.5); border: 2px solid #f1c40f; }
        .boost-item { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
        .boost-info { text-align: left; flex: 1; }
        .boost-name { font-weight: bold; color: #f1c40f; font-size: 1rem; }
        .boost-cost { color: #bbb; font-size: 0.85rem; }
        .boost-level { color: #3498db; font-size: 0.85rem; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: flex; align-items: center; justify-content: center; z-index: 1000; font-size: 1.5rem; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="loading"><div>Loading...</div></div>
    <div id="header">
        <button id="unlocks-btn" onclick="toggleUnlocks()">üé¥ UNLOCKS</button>
        
        <div id="unlocks-panel" class="unlocks-panel hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="font-size: 1.3rem; font-weight: bold; color: #9b59b6;">üé¥ Card Unlocks</div>
                <button onclick="toggleUnlocks()" style="background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 15px; font-weight: bold; cursor: pointer;">‚úñÔ∏è CLOSE</button>
            </div>
            
            <div style="color: #bbb; font-size: 0.85rem; margin-bottom: 15px; text-align: center;">
                Unlock rare cards by reaching milestones!
            </div>
            
            <div class="card-grid">
                <!-- Card 1 -->
                <div class="card-item" id="card-1" data-card="1">
                    <div class="card-locked-overlay" id="lock-1">üîí</div>
                    <img src="card_1.png" class="card-image" id="img-1" style="display: none;">
                    <div class="card-name">Mystery Card #1</div>
                    <div class="card-cost">Cost: 1,000,000 coins</div>
                    <button class="card-unlock-btn" onclick="unlockCard(1)" id="unlock-btn-1">UNLOCK</button>
                </div>
                
                <!-- More cards will be added here -->
            </div>
        </div>
        
        <div id="boost-timer-container">
            <div class="boost-timer-row">
                <div class="boost-timer-label">‚ö° Tap:</div>
                <div class="boost-timer-bar-wrapper">
                    <div class="boost-timer-bar-bg">
                        <div id="tap-timer-bar" class="boost-timer-bar tap-timer-bar"></div>
                    </div>
                </div>
                <div class="boost-timer-label" id="tap-timer-text">4:00</div>
            </div>
            <div class="boost-timer-row">
                <div class="boost-timer-label">‚ö° Regen:</div>
                <div class="boost-timer-bar-wrapper">
                    <div class="boost-timer-bar-bg">
                        <div id="regen-timer-bar" class="boost-timer-bar regen-timer-bar"></div>
                    </div>
                </div>
                <div class="boost-timer-label" id="regen-timer-text">4:00</div>
            </div>
        </div>
        
        <img src="coin.png" id="coin-icon">
        <div id="score">0</div>
    </div>
    <div id="game-area"><img id="face" src="face.png"></div>
    <div class="footer">
        <div id="refill-panel" class="refill-panel hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="font-size: 1.2rem; font-weight: bold; color: #3498db;">‚ö° Energy Refills</div>
                <button onclick="toggleRefills()" style="background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 15px; font-weight: bold; cursor: pointer;">‚úñÔ∏è CLOSE</button>
            </div>
            
            <div class="refill-info">
                <div class="refill-count" id="refill-count">?</div>
                <div style="color: #3498db; font-weight: bold; margin-bottom: 20px;">Available Refills</div>
                
                <button class="btn" onclick="useRefillFromPanel()" id="use-refill-btn" style="margin-bottom: 15px;">‚ö° USE REFILL NOW</button>
                
                <div class="refill-text">
                    <strong style="color: #f1c40f;">üéÅ How to Get More Refills:</strong><br>
                    Invite friends to play and earn 1 refill per friend!<br><br>
                    1. Click "SHARE INVITE" below<br>
                    2. Send your unique link to friends<br>
                    3. When they join, you get a refill!<br>
                    4. Use refills to instantly fill your energy
                </div>
                
                <button class="btn" onclick="shareInviteFromPanel()" style="background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); margin-top: 15px;">üì§ SHARE INVITE LINK</button>
            </div>
        </div>
        
        <div id="boost-panel" class="boost-panel hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="font-size: 1.2rem; font-weight: bold; color: #f1c40f;">üöÄ Boosts</div>
                <button onclick="toggleBoosts()" style="background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 15px; font-weight: bold; cursor: pointer;">‚úñÔ∏è CLOSE</button>
            </div>
            <div class="boost-item">
                <div class="boost-info">
                    <div class="boost-name">‚ö° Tap Power</div>
                    <div class="boost-cost">Cost: <span id="tap-cost">100</span> coins</div>
                    <div class="boost-level">Level: <span id="tap-level">1</span></div>
                </div>
                <button class="btn btn-small" onclick="buyBoost('tap')">BUY</button>
            </div>
            <div class="boost-item">
                <div class="boost-info">
                    <div class="boost-name">üîã Max Energy</div>
                    <div class="boost-cost">Cost: <span id="energy-cost">500</span> coins</div>
                    <div class="boost-level">Level: <span id="energy-level">1</span></div>
                </div>
                <button class="btn btn-small" onclick="buyBoost('energy')">BUY</button>
            </div>
            <div class="boost-item">
                <div class="boost-info">
                    <div class="boost-name">‚ö° Energy Regen</div>
                    <div class="boost-cost">Cost: <span id="regen-cost">300</span> coins</div>
                    <div class="boost-level">Level: <span id="regen-level">1</span></div>
                </div>
                <button class="btn btn-small" onclick="buyBoost('regen')">BUY</button>
            </div>
        </div>
        
        <div id="energy-label">Energy: <span id="e-val">1000</span>/1000</div>
        <div id="energy-container"><div id="energy-bar"></div></div>
        
        <button class="btn" id="boost-btn" onclick="toggleBoosts()">üöÄ BOOSTS</button>
        <button class="btn" id="refill-btn" onclick="toggleRefills()">‚ö° REFILL</button>
        <button class="btn" id="sync-btn" onclick="syncAndRank()">üíæ SYNC & RANK</button>
    </div>
    <script>
        const tg = window.Telegram.WebApp;
        tg.ready(); 
        tg.expand();
        
        // Game version - increment this to reset everyone's boost levels
        const GAME_VERSION = 4; // Changed from 3 - triggers full reset
        
        let score = 0, tapPower = 1, energy = 1000, totalTaps = 0, isLoading = true;
        const MAX_ENERGY = 1000;
        
        // Advanced Anti-cheat system (relaxed for better UX)
        const MAX_TAPS_PER_SECOND = 20; // Increased from 15 - allow faster legit tapping
        const MIN_TAP_INTERVAL = 25; // Reduced from 30ms - allow slightly faster taps
        const VARIANCE_THRESHOLD = 5; // Reduced from 10 - only catch extremely consistent bots
        const PATTERN_CHECK_SIZE = 20; // Number of taps to analyze for patterns
        
        let tapTimestamps = [];
        let lastTapTime = 0;
        let suspiciousActivityCount = 0;
        let isFlagged = false;
        
        // Position-based anti-cheat (prevent same-spot auto-clickers)
        let lastTapPositions = []; // Track last 2 tap positions for same-spot detection
        const MAX_SAME_POSITION_TAPS = 5; // Increased from 2 - allow more taps in same area
        
        // Pattern detection (detect repeating sequences)
        let tapPositionHistory = []; // Track last 20 positions for pattern analysis
        const PATTERN_HISTORY_SIZE = 20;
        const MIN_PATTERN_LENGTH = 4; // Increased from 3 - only catch longer patterns
        const MAX_PATTERN_LENGTH = 8; // Maximum sequence length to check
        
        // Face animation
        let currentFace = 'face.png'; // Track which face is showing
        
        // Boost system
        let tapPowerLevel = 1;
        let maxEnergyLevel = 1;
        let energyRegenLevel = 1;
        let lastSaveTime = Date.now(); // Track when game was last saved
        let lastTapPowerCheckTime = Date.now(); // Track tap power deterioration
        let lastEnergyRegenCheckTime = Date.now(); // Track energy regen deterioration
        // Note: Max Energy doesn't deteriorate separately, only the other two
        
        // Card unlock system
        let unlockedCards = []; // Array of unlocked card IDs
        const CARD_COSTS = {
            1: 1000000,
            // More cards can be added here later
        };
        
        // Boost deterioration settings
        const BOOST_DETERIORATION_HOURS = 4; // Boosts decay every 4 hours
        const BOOST_LEVEL_CAP_WITHOUT_CARD = 5; // Max level without card unlock
        
        function getMaxEnergy() {
            return 1000 + (maxEnergyLevel - 1) * 500;
        }
        
        function getEnergyRegen() {
            return getEnergyRegenRate(); // Now uses the unified rate function
        }
        
        function getTapPower() {
            return tapPowerLevel;
        }
        
        function getBoostCost(type) {
            if (type === 'tap') return 100 * Math.pow(2, tapPowerLevel - 1);
            if (type === 'energy') return 500 * Math.pow(2, maxEnergyLevel - 1);
            if (type === 'regen') return 300 * Math.pow(2, energyRegenLevel - 1);
            return 0;
        }
        
        function getEnergyRegenRate() {
            // Much more subtle: Base 1/sec + 0.2/sec per level
            // Level 1 = 1.2/sec, Level 5 = 2.0/sec, Level 10 = 3.0/sec
            // This prevents infinite tapping even at high levels
            return 1 + (energyRegenLevel * 0.2);
        }
        
        function processOfflineProgress(lastTime) {
            const now = Date.now();
            const timePassed = now - lastTime; // milliseconds
            const secondsPassed = timePassed / 1000;
            const hoursPassed = timePassed / (1000 * 60 * 60);
            
            // === OFFLINE ENERGY REGENERATION ===
            const energyToAdd = secondsPassed * getEnergyRegenRate();
            energy = Math.min(energy + energyToAdd, getMaxEnergy());
            
            // === BOOST DETERIORATION ===
            const deteriorationCycles = Math.floor(hoursPassed / BOOST_DETERIORATION_HOURS);
            
            if (deteriorationCycles > 0) {
                let deteriorated = false;
                
                // Deteriorate each boost
                if (tapPowerLevel > 1) {
                    tapPowerLevel = Math.max(1, tapPowerLevel - deteriorationCycles);
                    deteriorated = true;
                }
                if (maxEnergyLevel > 1) {
                    maxEnergyLevel = Math.max(1, maxEnergyLevel - deteriorationCycles);
                    deteriorated = true;
                }
                if (energyRegenLevel > 1) {
                    energyRegenLevel = Math.max(1, energyRegenLevel - deteriorationCycles);
                    deteriorated = true;
                }
                
                // Re-apply boost calculations after deterioration
                tapPower = getTapPower();
                energy = Math.min(energy, getMaxEnergy());
                
                if (deteriorated) {
                    // Show alert about deterioration
                    const hoursAway = Math.floor(hoursPassed);
                    tg.showAlert(
                        `‚ö†Ô∏è Boost Deterioration!\n\n` +
                        `You were away for ${hoursAway} hours.\n` +
                        `Your boosts have deteriorated by ${deteriorationCycles} level(s).\n\n` +
                        `Keep playing to maintain your boosts!`
                    );
                }
            }
            
            return {
                energyAdded: energyToAdd,
                deteriorationCycles: deteriorationCycles
            };
        }
        
        function detectRepeatingPattern(positions) {
            // Check if tap positions form a repeating pattern (like a macro/bot sequence)
            if (positions.length < MIN_PATTERN_LENGTH * 2) {
                return false; // Not enough data
            }
            
            // Try different pattern lengths (4, 5, 6, 7, 8 positions)
            for (let patternLen = MIN_PATTERN_LENGTH; patternLen <= MAX_PATTERN_LENGTH; patternLen++) {
                if (positions.length < patternLen * 2) continue;
                
                // Get the last N positions as potential pattern
                const recentPattern = positions.slice(-patternLen);
                
                // Check if this pattern repeats in the previous positions
                const previousSegment = positions.slice(-patternLen * 2, -patternLen);
                
                // Compare the two segments
                let matchCount = 0;
                for (let i = 0; i < patternLen; i++) {
                    // Allow larger position variance (within 15 pixels, increased from 5)
                    const [x1, y1] = recentPattern[i].split(',').map(Number);
                    const [x2, y2] = previousSegment[i].split(',').map(Number);
                    
                    const distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
                    
                    if (distance < 15) { // Within 15 pixels = same position (increased from 5)
                        matchCount++;
                    }
                }
                
                // If 90% or more positions match, it's a repeating pattern (increased from 80%)
                if (matchCount >= patternLen * 0.9) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Load from cloud storage
        tg.CloudStorage.getItems(['score', 'tapPower', 'totalTaps', 'energy', 'tapPowerLevel', 'maxEnergyLevel', 'energyRegenLevel', 'gameVersion', 'unlockedCards', 'lastSaveTime', 'lastTapPowerCheckTime', 'lastEnergyRegenCheckTime'], (err, values) => {
            if (!err && values) {
                const savedVersion = parseInt(values.gameVersion) || 1;
                
                // Check if version changed (admin reset)
                if (savedVersion !== GAME_VERSION) {
                    // Version mismatch - FULL RESET
                    score = 0;
                    totalTaps = 0;
                    energy = 1000;
                    tapPowerLevel = 1;
                    maxEnergyLevel = 1;
                    energyRegenLevel = 1;
                    
                    // Save new version and reset everything
                    tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
                    tg.CloudStorage.setItem('score', '0');
                    tg.CloudStorage.setItem('totalTaps', '0');
                    tg.CloudStorage.setItem('energy', '1000');
                    tg.CloudStorage.setItem('tapPowerLevel', '1');
                    tg.CloudStorage.setItem('maxEnergyLevel', '1');
                    tg.CloudStorage.setItem('energyRegenLevel', '1');
                    
                    tg.showAlert("üîÑ Game Reset!\n\nAll progress has been reset.\nEveryone starts fresh!");
                } else {
                    // Normal load - same version
                    score = parseInt(values.score) || 0;
                    totalTaps = parseInt(values.totalTaps) || 0;
                    energy = parseInt(values.energy) || 1000;
                    
                    // Load boost levels
                    tapPowerLevel = parseInt(values.tapPowerLevel) || 1;
                    maxEnergyLevel = parseInt(values.maxEnergyLevel) || 1;
                    energyRegenLevel = parseInt(values.energyRegenLevel) || 1;
                    
                    // Load unlocked cards
                    try {
                        unlockedCards = JSON.parse(values.unlockedCards || '[]');
                    } catch (e) {
                        unlockedCards = [];
                    }
                    
                    // Process offline progress (energy regen + boost deterioration)
                    const savedTime = parseInt(values.lastSaveTime) || Date.now();
                    const savedTapTime = parseInt(values.lastTapPowerCheckTime) || Date.now();
                    const savedRegenTime = parseInt(values.lastEnergyRegenCheckTime) || Date.now();
                    if (savedTime < Date.now() - 5000) { // Only if away for more than 5 seconds
                        processOfflineProgress(savedTime);
                    }
                    
                    // Load boost check times (for timer display)
                    lastTapPowerCheckTime = savedTapTime;
                    lastEnergyRegenCheckTime = savedRegenTime;
                }
                
                // Update current save time
                lastSaveTime = Date.now();
                // Don't reset timer check times here - they should persist
                
                // Apply boosts
                tapPower = getTapPower();
                energy = Math.min(energy, getMaxEnergy());
                
                // Update boost UI
                document.getElementById('tap-level').innerText = tapPowerLevel;
                document.getElementById('energy-level').innerText = maxEnergyLevel;
                document.getElementById('regen-level').innerText = energyRegenLevel;
                document.getElementById('tap-cost').innerText = getBoostCost('tap').toLocaleString();
                document.getElementById('energy-cost').innerText = getBoostCost('energy').toLocaleString();
                document.getElementById('regen-cost').innerText = getBoostCost('regen').toLocaleString();
                document.getElementById('energy-label').innerHTML = `Energy: <span id="e-val">${Math.floor(energy)}</span>/${getMaxEnergy()}`;
            } else {
                // First time player - set version
                tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
            }
            updateUI();
            isLoading = false;
            document.getElementById('loading').classList.add('hidden');
        });
        
        setTimeout(() => { 
            if (isLoading) { 
                isLoading = false; 
                document.getElementById('loading').classList.add('hidden'); 
                updateUI(); 
            } 
        }, 3000);
        
        function updateUI() {
            document.getElementById('score').innerText = score.toLocaleString();
            const eVal = document.getElementById('e-val');
            if (eVal) eVal.innerText = Math.floor(energy);
            const maxEnergy = getMaxEnergy();
            document.getElementById('energy-bar').style.width = (energy / maxEnergy * 100) + "%";
        }
        
        function updateBoostTimer() {
            const now = Date.now();
            const fourHoursInMs = BOOST_DETERIORATION_HOURS * 60 * 60 * 1000;
            
            // === TAP POWER TIMER ===
            const tapTimeSinceCheck = now - lastTapPowerCheckTime;
            const tapTimeRemaining = Math.max(0, fourHoursInMs - tapTimeSinceCheck);
            const tapPercentage = (tapTimeRemaining / fourHoursInMs) * 100;
            
            const tapBar = document.getElementById('tap-timer-bar');
            if (tapBar) {
                tapBar.style.width = tapPercentage + '%';
            }
            
            const tapMinutes = Math.floor(tapTimeRemaining / (1000 * 60));
            const tapSeconds = Math.floor((tapTimeRemaining % (1000 * 60)) / 1000);
            const tapTimeText = `${tapMinutes}:${String(tapSeconds).padStart(2, '0')}`;
            const tapLabel = document.getElementById('tap-timer-text');
            if (tapLabel) {
                tapLabel.innerText = tapTimeText;
            }
            
            // Check if tap power timer expired
            if (tapTimeRemaining === 0 && tapPowerLevel > 1) {
                tapPowerLevel = Math.max(1, tapPowerLevel - 1);
                lastTapPowerCheckTime = Date.now();
                tapPower = getTapPower();
                
                document.getElementById('tap-level').innerText = tapPowerLevel;
                document.getElementById('tap-cost').innerText = getBoostCost('tap').toLocaleString();
                
                tg.showAlert("‚ö†Ô∏è Tap Power Deteriorated!\n\nTap Power dropped by 1 level.");
                
                tg.CloudStorage.setItem('tapPowerLevel', String(tapPowerLevel));
                tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
            }
            
            // === ENERGY REGEN TIMER ===
            const regenTimeSinceCheck = now - lastEnergyRegenCheckTime;
            const regenTimeRemaining = Math.max(0, fourHoursInMs - regenTimeSinceCheck);
            const regenPercentage = (regenTimeRemaining / fourHoursInMs) * 100;
            
            const regenBar = document.getElementById('regen-timer-bar');
            if (regenBar) {
                regenBar.style.width = regenPercentage + '%';
            }
            
            const regenMinutes = Math.floor(regenTimeRemaining / (1000 * 60));
            const regenSeconds = Math.floor((regenTimeRemaining % (1000 * 60)) / 1000);
            const regenTimeText = `${regenMinutes}:${String(regenSeconds).padStart(2, '0')}`;
            const regenLabel = document.getElementById('regen-timer-text');
            if (regenLabel) {
                regenLabel.innerText = regenTimeText;
            }
            
            // Check if energy regen timer expired
            if (regenTimeRemaining === 0 && energyRegenLevel > 1) {
                energyRegenLevel = Math.max(1, energyRegenLevel - 1);
                lastEnergyRegenCheckTime = Date.now();
                
                document.getElementById('regen-level').innerText = energyRegenLevel;
                document.getElementById('regen-cost').innerText = getBoostCost('regen').toLocaleString();
                
                tg.showAlert("‚ö†Ô∏è Energy Regen Deteriorated!\n\nEnergy Regen dropped by 1 level.");
                
                tg.CloudStorage.setItem('energyRegenLevel', String(energyRegenLevel));
                tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
            }
            
            // Note: Max Energy deteriorates with offline progress only, not with timer
        }
        
        // Update boost timer every second
        setInterval(updateBoostTimer, 1000);
        
        setInterval(() => { 
            const maxEnergy = getMaxEnergy();
            if (energy < maxEnergy) { 
                energy = Math.min(maxEnergy, energy + getEnergyRegen());
                updateUI(); 
            } 
        }, 1000);
        
        setInterval(() => { 
            if (!isLoading) { 
                lastSaveTime = Date.now();
                tg.CloudStorage.setItem('score', String(score));
                tg.CloudStorage.setItem('tapPower', String(tapPower));
                tg.CloudStorage.setItem('totalTaps', String(totalTaps));
                tg.CloudStorage.setItem('energy', String(Math.floor(energy)));
                tg.CloudStorage.setItem('tapPowerLevel', String(tapPowerLevel));
                tg.CloudStorage.setItem('maxEnergyLevel', String(maxEnergyLevel));
                tg.CloudStorage.setItem('energyRegenLevel', String(energyRegenLevel));
                tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
                tg.CloudStorage.setItem('unlockedCards', JSON.stringify(unlockedCards));
                tg.CloudStorage.setItem('lastSaveTime', String(lastSaveTime));
                tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
                tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
            } 
        }, 30000);
        
        document.getElementById('face').addEventListener('click', function(e) {
            if (energy >= 1 && !isFlagged) {
                const now = Date.now();
                
                try {
                    // === LAYER 1: Rate Limiting ===
                    tapTimestamps.push(now);
                    tapTimestamps = tapTimestamps.filter(t => now - t < 1000);
                    
                    if (tapTimestamps.length > MAX_TAPS_PER_SECOND) {
                        suspiciousActivityCount++;
                        tg.HapticFeedback.notificationOccurred('error');
                        
                        // Only warn after 5 violations (not 3)
                        if (suspiciousActivityCount >= 5) {
                            tg.showAlert("‚ö†Ô∏è Tapping too fast! Slow down a bit.");
                        }
                        
                        // Only flag after 8 violations (not 3)
                        if (suspiciousActivityCount >= 8) {
                            isFlagged = true;
                            score = 0;
                            tg.showAlert("üö´ AUTO-TAPPER DETECTED!\n\nYour account has been flagged.\nScore reset to zero.");
                        }
                        return;
                    }
                    
                    // === LAYER 2: Minimum Interval Check ===
                    const timeSinceLastTap = now - lastTapTime;
                    if (lastTapTime > 0 && timeSinceLastTap < MIN_TAP_INTERVAL) {
                        suspiciousActivityCount++;
                        
                        // Only flag after 10 violations (not 5)
                        if (suspiciousActivityCount >= 10) {
                            isFlagged = true;
                            score = 0;
                            tg.HapticFeedback.notificationOccurred('error');
                            tg.showAlert("üö´ IMPOSSIBLE TAP SPEED DETECTED!\n\nYour account has been flagged.\nScore reset to zero.");
                        }
                        return;
                    }
                    lastTapTime = now;
                    
                    // === LAYER 3: Bot Pattern Detection (Variance Analysis) ===
                    if (tapTimestamps.length >= PATTERN_CHECK_SIZE) {
                        const intervals = [];
                        for (let i = 1; i < Math.min(tapTimestamps.length, PATTERN_CHECK_SIZE); i++) {
                            intervals.push(tapTimestamps[i] - tapTimestamps[i-1]);
                        }
                        
                        if (intervals.length >= 10) {
                            const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                            const variance = intervals.reduce((sum, interval) => {
                                return sum + Math.pow(interval - avgInterval, 2);
                            }, 0) / intervals.length;
                            
                            // Bots have very consistent intervals (low variance)
                            // Humans naturally vary between 50-200ms variance
                            // Only flag extremely consistent patterns (variance < 5ms)
                            if (variance < VARIANCE_THRESHOLD && avgInterval < 80) {
                                suspiciousActivityCount += 2;
                                
                                // Only flag after 6 detections (not 3)
                                if (suspiciousActivityCount >= 6) {
                                    isFlagged = true;
                                    score = 0;
                                    tg.showAlert("üö´ BOT PATTERN DETECTED!\n\nPerfectly consistent tapping is not human.\n\nYour account has been flagged.\nScore reset to zero.");
                                    return;
                                }
                            }
                        }
                    }
                    
                    // === LAYER 4: Same-Position Detection ===
                    // Track tap position to detect auto-clickers stuck in one spot
                    const tapX = Math.round(e.clientX);
                    const tapY = Math.round(e.clientY);
                    const currentPosition = `${tapX},${tapY}`;
                    
                    // Check if last 5 taps were in exact same position (increased from 2)
                    if (lastTapPositions.length >= MAX_SAME_POSITION_TAPS) {
                        const allSamePosition = lastTapPositions.every(pos => pos === currentPosition);
                        
                        if (allSamePosition) {
                            suspiciousActivityCount += 2;
                            
                            // Only flag after 8 violations (not 4)
                            if (suspiciousActivityCount >= 8) {
                                isFlagged = true;
                                score = 0;
                                tg.HapticFeedback.notificationOccurred('error');
                                tg.showAlert("üö´ AUTO-CLICKER DETECTED!\n\nTapping in exact same spot repeatedly.\n\nYour account has been flagged.\nScore reset to zero.");
                            } else {
                                // Only warn on first few times
                                if (suspiciousActivityCount <= 4) {
                                    tg.HapticFeedback.notificationOccurred('warning');
                                    tg.showAlert("‚ö†Ô∏è Move your finger around!\n\nTapping in the same spot looks suspicious.");
                                }
                            }
                            return;
                        }
                    }
                    
                    // Update position tracking (keep last 2 positions)
                    lastTapPositions.push(currentPosition);
                    if (lastTapPositions.length > MAX_SAME_POSITION_TAPS) {
                        lastTapPositions.shift();
                    }
                    
                    // === LAYER 5: Repeating Pattern Detection ===
                    // DISABLED - Too many false positives with multi-finger tapping
                    // Track positions for pattern analysis
                    tapPositionHistory.push(currentPosition);
                    if (tapPositionHistory.length > PATTERN_HISTORY_SIZE) {
                        tapPositionHistory.shift();
                    }
                    
                    // Pattern detection disabled - causes false positives with:
                    // - Two-finger tapping (creates natural A-B-A-B pattern)
                    // - Thumb tapping (natural tendency to alternate spots)
                    // - Fast tapping (naturally creates patterns)
                    
                    /* PATTERN DETECTION DISABLED
                    if (tapPositionHistory.length >= MIN_PATTERN_LENGTH * 2) {
                        if (detectRepeatingPattern(tapPositionHistory)) {
                            suspiciousActivityCount += 3;
                            
                            if (suspiciousActivityCount >= 9) {
                                isFlagged = true;
                                score = 0;
                                tg.HapticFeedback.notificationOccurred('error');
                                tg.showAlert("üö´ MACRO PATTERN DETECTED!\n\nRepeating tap sequence detected.\n\nYour account has been flagged.\nScore reset to zero.");
                                return;
                            }
                        }
                    }
                    */
                    
                    // Aggressive forgiveness system - decay suspicious activity counter
                    // 30% chance per tap to reduce counter (increased from 10%)
                    if (suspiciousActivityCount > 0 && Math.random() < 0.3) {
                        suspiciousActivityCount = Math.max(0, suspiciousActivityCount - 1);
                    }
                    
                } catch (error) {
                    // Fail silently on anti-cheat errors to prevent game breaking
                    console.error('Anti-cheat error:', error);
                }
                
                // === Normal tap processing ===
                score += tapPower;
                energy -= 1;
                totalTaps += 1;
                
                tg.HapticFeedback.impactOccurred('medium');
                
                // Flash effect + alternate face images
                const face = document.getElementById('face');
                face.classList.add('flash');
                
                // Alternate between face.png and face_1.png
                currentFace = (currentFace === 'face.png') ? 'face_1.png' : 'face.png';
                face.src = currentFace;
                
                setTimeout(() => face.classList.remove('flash'), 200);
                
                const effect = document.createElement('div');
                effect.className = 'tap-effect';
                effect.innerText = `+${tapPower}`;
                effect.style.left = e.clientX + 'px';
                effect.style.top = e.clientY + 'px';
                document.getElementById('game-area').appendChild(effect);
                
                setTimeout(() => effect.remove(), 1000);
                updateUI();
            } else if (isFlagged) {
                tg.HapticFeedback.notificationOccurred('error');
                tg.showAlert("üö´ Account flagged for cheating.\n\nRestart the game to try again.");
            } else {
                tg.HapticFeedback.notificationOccurred('error');
            }
        });
        
        function toggleBoosts() {
            const panel = document.getElementById('boost-panel');
            const btn = document.getElementById('boost-btn');
            const refillPanel = document.getElementById('refill-panel');
            const unlocksPanel = document.getElementById('unlocks-panel');
            
            // Close other panels
            if (!refillPanel.classList.contains('hidden')) {
                refillPanel.classList.add('hidden');
            }
            if (!unlocksPanel.classList.contains('hidden')) {
                unlocksPanel.classList.add('hidden');
            }
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                btn.innerText = "üöÄ BOOSTS ‚ñ≤";
            } else {
                panel.classList.add('hidden');
                btn.innerText = "üöÄ BOOSTS";
            }
        }
        
        function toggleRefills() {
            const panel = document.getElementById('refill-panel');
            const boostPanel = document.getElementById('boost-panel');
            const boostBtn = document.getElementById('boost-btn');
            const unlocksPanel = document.getElementById('unlocks-panel');
            
            // Close other panels
            if (!boostPanel.classList.contains('hidden')) {
                boostPanel.classList.add('hidden');
                boostBtn.innerText = "üöÄ BOOSTS";
            }
            if (!unlocksPanel.classList.contains('hidden')) {
                unlocksPanel.classList.add('hidden');
            }
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                // Fetch current refill count from bot
                fetchRefillCount();
            } else {
                panel.classList.add('hidden');
            }
        }
        
        function toggleUnlocks() {
            const panel = document.getElementById('unlocks-panel');
            const boostPanel = document.getElementById('boost-panel');
            const boostBtn = document.getElementById('boost-btn');
            const refillPanel = document.getElementById('refill-panel');
            
            // Close other panels
            if (!boostPanel.classList.contains('hidden')) {
                boostPanel.classList.add('hidden');
                boostBtn.innerText = "üöÄ BOOSTS";
            }
            if (!refillPanel.classList.contains('hidden')) {
                refillPanel.classList.add('hidden');
            }
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                updateCardDisplay();
            } else {
                panel.classList.add('hidden');
            }
        }
        
        function unlockCard(cardId) {
            const cost = CARD_COSTS[cardId];
            
            if (!cost) {
                tg.showAlert("Invalid card!");
                return;
            }
            
            if (unlockedCards.includes(cardId)) {
                tg.showAlert("You already own this card!");
                return;
            }
            
            if (score < cost) {
                tg.showAlert(`Not enough coins! You need ${cost.toLocaleString()} coins.\n\nYou have: ${score.toLocaleString()}`);
                return;
            }
            
            // Deduct coins
            score -= cost;
            
            // Unlock card
            unlockedCards.push(cardId);
            
            // Save to cloud storage
            lastSaveTime = Date.now();
            tg.CloudStorage.setItem('score', String(score));
            tg.CloudStorage.setItem('unlockedCards', JSON.stringify(unlockedCards));
            tg.CloudStorage.setItem('lastSaveTime', String(lastSaveTime));
            tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
            tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
            
            // Update UI
            updateUI();
            updateCardDisplay();
            
            tg.HapticFeedback.notificationOccurred('success');
            tg.showAlert(`üéâ Card Unlocked!\n\nYou unlocked Mystery Card #${cardId}!`);
        }
        
        function updateCardDisplay() {
            // Update each card's display based on unlock status
            Object.keys(CARD_COSTS).forEach(cardId => {
                const cardNum = parseInt(cardId);
                const cardItem = document.getElementById(`card-${cardNum}`);
                const lockIcon = document.getElementById(`lock-${cardNum}`);
                const cardImage = document.getElementById(`img-${cardNum}`);
                const unlockBtn = document.getElementById(`unlock-btn-${cardNum}`);
                
                if (unlockedCards.includes(cardNum)) {
                    // Card is unlocked
                    cardItem.classList.remove('locked');
                    cardItem.classList.add('unlocked');
                    lockIcon.style.display = 'none';
                    cardImage.style.display = 'block';
                    unlockBtn.innerText = 'OWNED';
                    unlockBtn.disabled = true;
                } else {
                    // Card is locked
                    cardItem.classList.add('locked');
                    cardItem.classList.remove('unlocked');
                    lockIcon.style.display = 'block';
                    cardImage.style.display = 'none';
                    
                    // Check if player can afford it
                    const cost = CARD_COSTS[cardNum];
                    if (score >= cost) {
                        unlockBtn.disabled = false;
                        unlockBtn.innerText = 'UNLOCK';
                    } else {
                        unlockBtn.disabled = true;
                        unlockBtn.innerText = `Need ${(cost - score).toLocaleString()} more`;
                    }
                }
            });
        }
        
        function fetchRefillCount() {
            // For now, show "?" and user needs to check /boosts
            // In a real implementation, we'd query the bot's API
            document.getElementById('refill-count').innerText = "?";
            document.getElementById('refill-count').style.opacity = "0.5";
            
            const infoText = document.createElement('div');
            infoText.style.cssText = "color: #f39c12; font-size: 0.85rem; margin-top: 10px;";
            infoText.innerText = "üí° Use /boosts command in chat to see your exact count";
            
            const refillInfo = document.querySelector('.refill-info');
            const existingInfo = refillInfo.querySelector('div[style*="f39c12"]');
            if (!existingInfo) {
                refillInfo.insertBefore(infoText, refillInfo.children[2]);
            }
        }
        
        function useRefillFromPanel() {
            // If we don't know the boost count, warn user first
            const refillCount = document.getElementById('refill-count').innerText;
            
            if (refillCount === "?") {
                tg.showConfirm(
                    "Try to use a refill?\n\nIf you don't have any, you'll be prompted to invite friends.",
                    (confirmed) => {
                        if (confirmed) {
                            toggleRefills();
                            useEnergyBoost();
                        }
                    }
                );
            } else {
                toggleRefills();
                useEnergyBoost();
            }
        }
        
        function shareInviteFromPanel() {
            const userId = tg.initDataUnsafe?.user?.id || 
                          window.Telegram?.WebApp?.initDataUnsafe?.user?.id;
            
            if (!userId) {
                tg.showAlert("Please open the game from the Menu button to use this feature");
                return;
            }
            
            // Show confirmation popup
            tg.showConfirm(
                "Share your invite link?\n\nThis will close the game and open Telegram to share your link with friends.",
                (confirmed) => {
                    if (confirmed) {
                        const botUsername = "berttapbot";
                        const inviteLink = `https://t.me/${botUsername}?start=ref_${userId}`;
                        const shareText = `üéÆ Play Bert Tap Attack and earn rewards!\n\nüéÅ Use my invite link to get started!`;
                        
                        const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(inviteLink)}&text=${encodeURIComponent(shareText)}`;
                        tg.openLink(shareUrl);
                    }
                    // If not confirmed, just stay in game (do nothing)
                }
            );
        }
        
        function useEnergyBoost() {
            if (isLoading) return;
            
            const maxEnergy = getMaxEnergy();
            if (energy >= maxEnergy) {
                tg.showAlert("Your energy is already full!");
                return;
            }
            
            const btn = document.getElementById('use-refill-btn');
            btn.innerText = "‚è≥ USING...";
            btn.disabled = true;
            
            // Refill energy optimistically (bot will validate if boost exists)
            energy = maxEnergy;
            updateUI();
            
            // Send request to use boost (bot will confirm or deny)
            const dataToSend = JSON.stringify({ 
                action: 'use_boost'
            });
            
            setTimeout(() => {
                try {
                    tg.sendData(dataToSend);
                    btn.innerText = "‚ö° USE REFILL NOW";
                    btn.disabled = false;
                } catch (e) {
                    console.error('Boost error:', e);
                    btn.innerText = "‚ö° USE REFILL NOW";
                    btn.disabled = false;
                }
            }, 500);
        }
        
        function buyBoost(type) {
            const cost = getBoostCost(type);
            
            if (score < cost) {
                tg.showAlert(`Not enough coins! You need ${cost.toLocaleString()} coins.`);
                return;
            }
            
            // Check boost level cap
            const hasCard1 = unlockedCards.includes(1);
            let currentLevel = 0;
            if (type === 'tap') currentLevel = tapPowerLevel;
            if (type === 'energy') currentLevel = maxEnergyLevel;
            if (type === 'regen') currentLevel = energyRegenLevel;
            
            if (!hasCard1 && currentLevel >= BOOST_LEVEL_CAP_WITHOUT_CARD) {
                tg.showAlert(
                    `üîí Boost Level Cap Reached!\n\n` +
                    `You need to unlock Card #1 to upgrade beyond level ${BOOST_LEVEL_CAP_WITHOUT_CARD}.\n\n` +
                    `Check the UNLOCKS tab to purchase cards!`
                );
                return;
            }
            
            score -= cost;
            
            if (type === 'tap') {
                tapPowerLevel++;
                tapPower = getTapPower();
                document.getElementById('tap-level').innerText = tapPowerLevel;
                document.getElementById('tap-cost').innerText = getBoostCost('tap').toLocaleString();
                // Reset tap power timer when buying tap boost
                lastTapPowerCheckTime = Date.now();
            } else if (type === 'energy') {
                maxEnergyLevel++;
                energy = Math.min(energy, getMaxEnergy());
                document.getElementById('energy-level').innerText = maxEnergyLevel;
                document.getElementById('energy-cost').innerText = getBoostCost('energy').toLocaleString();
                document.getElementById('energy-label').innerHTML = `Energy: <span id="e-val">${Math.floor(energy)}</span>/${getMaxEnergy()}`;
                // Max energy doesn't have a separate timer
            } else if (type === 'regen') {
                energyRegenLevel++;
                document.getElementById('regen-level').innerText = energyRegenLevel;
                document.getElementById('regen-cost').innerText = getBoostCost('regen').toLocaleString();
                // Reset energy regen timer when buying regen boost
                lastEnergyRegenCheckTime = Date.now();
            }
            
            // Save boosts
            tg.CloudStorage.setItem('score', String(score));
            tg.CloudStorage.setItem('tapPowerLevel', String(tapPowerLevel));
            tg.CloudStorage.setItem('maxEnergyLevel', String(maxEnergyLevel));
            tg.CloudStorage.setItem('energyRegenLevel', String(energyRegenLevel));
            tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
            tg.CloudStorage.setItem('unlockedCards', JSON.stringify(unlockedCards));
            tg.CloudStorage.setItem('lastSaveTime', String(Date.now()));
            tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
            tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
            
            tg.HapticFeedback.notificationOccurred('success');
            updateUI();
        }
        
        function syncAndRank() {
            const btn = document.getElementById('sync-btn');
            if (isLoading || btn.disabled) return;
            
            btn.innerText = "üíæ SAVING...";
            btn.disabled = true;
            
            lastSaveTime = Date.now();
            
            // Save to cloud storage
            tg.CloudStorage.setItem('score', String(score));
            tg.CloudStorage.setItem('tapPower', String(tapPower));
            tg.CloudStorage.setItem('totalTaps', String(totalTaps));
            tg.CloudStorage.setItem('energy', String(Math.floor(energy)));
            tg.CloudStorage.setItem('tapPowerLevel', String(tapPowerLevel));
            tg.CloudStorage.setItem('maxEnergyLevel', String(maxEnergyLevel));
            tg.CloudStorage.setItem('energyRegenLevel', String(energyRegenLevel));
            tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
            tg.CloudStorage.setItem('unlockedCards', JSON.stringify(unlockedCards));
            tg.CloudStorage.setItem('lastSaveTime', String(lastSaveTime));
            tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
            tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
            
            // Wait a bit for cloud storage to complete
            setTimeout(() => {
                btn.innerText = "üöÄ SENDING...";
                
                const dataToSend = JSON.stringify({ 
                    score: isFlagged ? 0 : score,
                    totalTaps: totalTaps,
                    flagged: isFlagged,
                    suspiciousCount: suspiciousActivityCount
                });
                
                try {
                    tg.sendData(dataToSend);
                    
                    // Wait longer before closing to let everything save
                    setTimeout(() => tg.close(), 1500);
                    
                } catch (e) {
                    console.error('Send error:', e);
                    tg.showAlert("Error: " + e.message);
                    btn.innerText = "üíæ SYNC & RANK";
                    btn.disabled = false;
                }
            }, 300);
        }
        
        window.addEventListener('beforeunload', () => {
            lastSaveTime = Date.now();
            tg.CloudStorage.setItem('score', String(score));
            tg.CloudStorage.setItem('tapPower', String(tapPower));
            tg.CloudStorage.setItem('totalTaps', String(totalTaps));
            tg.CloudStorage.setItem('energy', String(Math.floor(energy)));
            tg.CloudStorage.setItem('tapPowerLevel', String(tapPowerLevel));
            tg.CloudStorage.setItem('maxEnergyLevel', String(maxEnergyLevel));
            tg.CloudStorage.setItem('energyRegenLevel', String(energyRegenLevel));
            tg.CloudStorage.setItem('gameVersion', String(GAME_VERSION));
            tg.CloudStorage.setItem('unlockedCards', JSON.stringify(unlockedCards));
            tg.CloudStorage.setItem('lastSaveTime', String(lastSaveTime));
            tg.CloudStorage.setItem('lastTapPowerCheckTime', String(lastTapPowerCheckTime));
            tg.CloudStorage.setItem('lastEnergyRegenCheckTime', String(lastEnergyRegenCheckTime));
        });
    </script>
</body>
</html>
